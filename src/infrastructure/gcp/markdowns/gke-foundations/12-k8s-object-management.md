_______________________________________________________________________________
### K8s Object Management
All K8s objects are identified by a unique name and a unique id.

#### Example: Keep 3 Nginx server running
The simplest way is to declare 3 pod objects and specify their state. For each, a pod must be created and an Nginx container image must be used.

You define the K8s objects which you want K8s to create and maintain with **manifest files**. The follow yaml file defines the desired state of a pod:

<pre>
apiVersion: apps/v1
kind: Pod
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
</pre>

When you create a K8s object, you name it with a string. **Names must be unique**.
* Only one object of a particular kind can have a particular name at the same time in a K8s namespace.
* If an object is deleted, its name can be reused.

Each object generated throughout the life of a cluster has a unique ID generated by K8s. No two objects will ahve the same UID throughout the life of a cluster.

Labels are key-value pairs with which you tag your objects during or after their creation.
* Labels help you identify and organize objects and subsets of objects.
* For example, you could create a label called app and give its value as its application of which this object is a part.

<pre>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    app: nginx
    env: dev
    stack: frontend
spec:
  replicas: 3
  selector:
    matchLabels
    app: nginx
</pre>

Command to listing all the pods with label `app` with a value of `nginx`
<pre>
> kubectl get pods -selector=app=nginx
</pre>

K8s default scheduling algorithm prefers to spread the workload evenly across the nodes available to it.

### Controller Objects
**Pods** do not heal or repair themselves and they are not meant to run forever. They are designed to be ephemeral and disposable. For these reasons, there are better ways to manage what you run in K8s than specifying individual pods like what we did above.

Question: how do you tell K8s to maintain the desired state of 3 Nginx containers?

You can declare a **Controller Object** instead of a Pod Object. The job of a controller object is to manage the state of the pods.

#### Controller Object Types
* Deployment
* StatefulSet
* DaemonSet
* Job

##### Deployment
Deployment object is a great choice for long-live software components, like web servers, especially when we want to manage them as a group.

In our example of keeping 3 Nginx servers running all the time, when `kube-scheduler` schedules pods for a deployment, it notifies the `kube-APIserver`. These changes are constantly monitored by controllers, especially by the deployment controllers.
* The deployment controller will monitor and maintain 3 Nginx pods.
  * If one of the 3 pods fails, the deployment controller will recognize the difference between the current state and the desired state, and it will try to fix it by launching a new pod.

Instead of using multiple yaml manifests for each pod, you use a single deployment yaml to launch 3 replicas of the same container.
* **A deployment ensures that a defined set of pods is running in any given time.**

<pre>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
</pre>

#### Organize cluster: K8s Namespaces
Each K8s cluster is associated with **ONE** GCP project.

How do you keep everybody work on your cluster organized? K8s allows you to abstract a single physical cluster into multiple clusters known as **namespaces**.

Namespaces provide scopes for naming resources such as pods, deployments, and controllers. For example, you can have 3 namespaces in your cluster: test, stage, prod.
* You cannot have duplicate object names under the **SAME** namespace.
* Namespaces let you implement resource quotas across the cluster. These quotas define limits for resource consumption within a namespace.

#### Other types of controller objects
A `ReplicaSet` controller ensures that a population of pods, all identical to one another, are running at the same time.

`Deployments` let you create, update, roll back and scale pods, using `ReplicaSets` as needed. When you perform a rolling upgrade of a Deployment, the Deployment object creates a second `ReplicaSet`, and then increases the number of pods in the new `ReplicaSet` as it decreases the number of pods in its original `ReplicaSet`.

If you need to deploy applications that maintain local state, `StatefulSet` is a better option. A `StatefulSet` is similar to a Deployment in that the pods use the same container spec. The pods created through `StatefulSet` are given unique persistent identities with stable network identity and persistend disk storage.

`DaemonSet` ensures that a specific pod is always running on all or some subset of the nodes.
* Daemon is a non-interactive process that provides useful services to other processes.
* K8s cluster might use a `DaemonSet` to ensure that a logging agent like fluentd is running on all nodes in the cluster.

`Job` controller creates one or more pods required to run a task. When the task is done, `Job` will then terminate all those pods. A related controller is `CronJob`, which runs pods on a time-based schedule.